===============================================================================
Contents
===============================================================================
1. Build
2. Dependencies
3. Flags
4. Design

===============================================================================
1. Build
===============================================================================

CMake 
  - Use CMake as the build system. 
    - It's widely supported, easy to use, and is the de facto standard for C++ 
      projects.
  - Version 3.31
    - Not much reason other than it's the latest version at the time of writing.
    - Need at least 3.21 for HIP_STANDARD and 3.23 for various CUDA features.

Static vs shared library
  - Static libraries provide more opportunity for optimization, but produce
    larger binaries and require more time to recompile if changes are made to
    the source.
  - Developers may want to use a shared library during development and release
    a static library for users.

C++ standard
  - The latest standard with (almost) full support, C++23.
  - We may have to resort to C++20 for CUDA. nvcc doesn't support C++23 yet.
  - We would like to use the following language features C++23:
    - #elifdef
    - Multidimensional subscript operator [i,j,k]
    - #warning
    - [[assume(expr)]]
  - We would like to use the following library features:
    - stacktrace library
    - std::string_view/string::contains
    - std::mdspan (thanks Kokkos!)

===============================================================================
2. Dependencies
===============================================================================

clang-format
  - Use clang-format to enforce a consistent code style.
    - Consistent style helps make code easier to read and maintain.
    - Being able to immediately see structure or that something is a variable, 
      function, etc. is very helpful.
  - We use LLVM style with a few modifications.
  - 90 column limit. The old 80 column limit is too restrictive, but 100 is 
    excessive for users on laptops or smaller monitors.
  - General style:
    - variable names: snake_case
    - function names: camelCase
    - class names: PascalCase
    - macros: ALL_CAPS
    - private member variables: _variableName
  - We use a "format-check" and "format-fix" target to check and fix formatting,
    respectively.

clang-tidy
  - Use clang-tidy to ensure code quality and to catch potential bugs.
  - Enabled checks:
    - bugprone-* Checks that target bug-prone code constructs.
    - cert-* Checks related to CERT Secure Coding Guidelines.
    - clang-analyzer-* Clang Static Analyzer checks.
    - cppcoreguidelines-* Checks related to C++ Core Guidelines.
    - llvm-* Checks related to the LLVM coding conventions.
    - misc-* Checks that didnâ€™t have a better category. 
    - modernize-* Checks that advocate usage of modern language constructs.
    - mpi-* Checks related to MPI (Message Passing Interface).
    - openmp-* Checks related to OpenMP API.
    - performance-* Checks that target performance-related issues.
    - portability-* Checks that target portability-related issues. 
    - readability-* Checks that target readability-related issues.
  - Disabled checks:
    - *-avoid-c-arrays: C arrays are acceptable in some circumstances.
    - *-magic-numbers: Magic numbers are acceptable in some circumstances.
    - bugprone-easily-swappable-parameters: Subjective.
    - clang-analyzer-osx*: We don't target macOS.
    - cppcoreguidelines-macro-usage: Macros for configuration are acceptable.
    - cppcoreguidelines-pro-bounds-array-to-pointer-decay: Can be perfectly safe 
      and performant.
    - cppcoreguidelines-pro-bounds-pointer-arithmetic:  Can be perfectly safe and 
      performant
    - cppcoreguidelines-pro-type-vararg: snprintf, etc.
    - llvm-header-guard: We use #pragma once.
    - modernize-use-ranges: Not while they are still lacking in performance.
    - modernize-use-std-print: Not supported by all compilers of interest.
    - readability-identifer-length: Makes doing math impossible. x + y = z is invalid.

OpenMP
  - Use OpenMP for multi-threading. It's widely supported and easy to use.
  - Kokkos can handle common multi-threaded operations using OpenMP as the backend.
    - Requires linking OpenMP

Kokkos
  - Currently the best option for performance portability with GPUs.
  - Always build Kokkos instead of using a system-installed version to ensure compiler 
    compatability and correct configuration. Also because Kokkos doesn't take long to 
    build.

===============================================================================
3. Flags
===============================================================================

General warnings
  -Wall: The standard, bare minimum set of warnings.
  -Wextra: Extra warnings that are generally useful.
  -Wcast-align: Warn whenever a pointer is cast such that the required alignment of the 
    target is increased.
  -Wcast-qual: Warn whenever a pointer is cast so as to remove a type qualifier from the
    target type.
  -Wconversion: Warn for implicit conversions that may alter a value.
  -Wdouble-promotion: Warn if float is implicit promoted to double.
  -Wfloat-equal: Warn if floating point values are compared for equality.
  -Wimplicit-fallthrough: Warn if a switch case falls through.
  -Wmissing-noreturn: Warn about functions which might be candidates for attribute noreturn.
  -Wnon-virtual-dtor: Warn when a class with virtual functions has a non-virtual destructor.
  -Wshadow: Warn whenever a local variable shadows another local variable.
  -Wunused: Warn whenever a variable is unused.
  -Wvla: Warn if variable length array is used.
  -Wzero-as-null-pointer-constant: Warn if zero is used as a null pointer constant.
  -Werror: Treat warnings as errors.
  -Wold-style-cast: Warn for C-style casts.
  -pedantic: Issue all the warnings demanded by strict ISO C and ISO C++.

Compiler-specific warnings
  -Wsuggest-attribute=noreturn: Suggest that a function be marked as noreturn. 
  -Wunreachable-code: Warn if the compiler detects that code will never be executed.
  -Wconditional-uninitialized: Warn if a variable is used without being initialized.
  -Wheader-hygiene: Warn if a header is included that is not needed.
  -Woverriding-method-mismatch: Warn if a method is overridden with a different signature.
  -Wrange-loop-analysis: Loop related warnings. 
  -Wreserved-identifier: Warn if a reserved identifier is used.
  -Wshadow-all: Warn whenever a local variable shadows another variable.
  -Wshift-sign-overflow: Warn if a shift operation caused the sign of the result to change.
  -Wtautological-compare: Warn if a comparison is always true or always false.
  -Wunaligned-access: Warn of unaligned memory access to aligned types.
  -Wunneeded-member-function: Warn if a member function is not needed.
  -Wundef: Warn if an undefined identifier is used in an #if directive.
  -Wvector-conversion: Warn if a vector conversion is problematic. 

Optimization
  -march=native: Generate instructions for the local machine.
  -flto: Run the link-time optimizer.
  - Either "-Ofast" or "-O3" and the flags below (a subset of -ffast-math).
    -ffinite-math-only: Assume that arguments and results are not NaNs or +-Infs.
    -fno-signed-zeros: Ignore the signedness of zero (-0.0 == 0.0 == +0.0).
    -fno-trapping-math: Assume FP operations cannot generate user-visible traps. These traps 
      include division by zero, overflow, underflow, inexact result and invalid operation.
    -fno-math-errno: Do not set errno after calling math functions that are executed with a 
      single instruction, e.g., sqrt.
    -fno-rounding-math: Assume that the rounding mode is set to FE_TONEAREST.
    -fpp-contract=fast: Enables floating-point expression contraction such as forming of 
      fused multiply-add operations

Debug
  -g: Produce debugging information.
  -fsanitize: Turn on runtime checks for various forms of undefined or suspicious behavior.
    - memory: A detector of uninitialized reads.
    - address: A memory error detector.
    - undefined: An undefined behavior checker.
  -fno-omit-frame-pointer: Don't omit frame pointers for better stack traces.

===============================================================================
4. Design
===============================================================================

Design by contract (DBC, Assert/Assume)
  - We want to check that preconditions and postconditions to functions are enforced.
    - This allows for easier debugging.
    - For example, if making our own sqrt(x), we likely want to ASSERT(x >= 0).
  - We want the checking of these conditions to be opt-in, and when not in use should 
    not impact performance.
  - We want the ASSERT to be usable in a relase build, which means that we have
    to make our own, since <assert> is disabled when NDEBUG is defined.
  - If we can assume a condition to be true, then we want the compiler to be able
    to do the same.
    - Use C++23 [[assume(expr)]] to provide optimization hints to the compiler.
    - Use ASSERT_ASSUME(expr) to assert that the expression is true when assertions 
      are enabled, and to assume that the expression is true when assertions are
      disabled.

Logging
  - Use a logger to handle debug, info, warning, and error messages.
  - Use compile-time and run-time configuration to control logging behavior.
  - Colorize output when logging to a terminal to make it easier to read.
  - Use the logger to exit the program when an error occurs (configurable).

Precision of fundamental types
  - The precision of Float, Int, etc. should be configured at compile time.
  - For simulations that require increased precision, the precision can then be
    changed for the entire library by modifying a single parameter.

Prefer header-only implementations
  - Increases compile times, but allows for transformations that would not be possible 
    with separate compilation (e.g. inlining, constant propagation, etc.)

Settings class
  - The only global variables should be those that MUST be available globally.
  - Therefore, we use a settings class to store this type of information, e.g. 
    enable timestamps for logging. 

Unit tests
  - We want to check that individual functions work as expected.
    - This allows for easier debugging.
  - We want to test for expected behavior, not for unexpected behavior.
    - The set of expected behaviors is much smaller than the set of unexpected 
      behaviors.
  - Use our own test macros. 
    - We only need simple behavior, so we don't need a full testing framework.
    - No unit testing library (that I'm aware of) allows for easy testing of host
      and device code without explicit duplication of code.

#benchmark
#libquadmath
#gcov
#replace valgrind with malt
